# -*- coding: utf-8 -*-
"""final_insurance_recommender (1).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YwUlo6IjUXxZ0aLk85WsPtxLKF4WvOgU
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

full_df = pd.read_excel("correlation_insurance.xlsx")
full_df.head()

cols_to_drop = ['ID' , "Name"]
df = full_df.drop(cols_to_drop , axis = 1)
df.head()

gender_mapper = {"F" : 0 , "M" : 1}
df['Gender'] = df['Gender'].map(gender_mapper)
df.head()

df['Plan Type'].value_counts()

plan_mapper = {"Basic" : 1 , "Standard" : 2 , "Premium" : 3}
df['Plan Type'] = df["Plan Type"].map(plan_mapper)

df.head()

married_mapper = {"Single" : 0 , "Married" : 1}
df['Marital Status'] = df['Marital Status'].map(married_mapper)
df.head()

def good_credit(credit):
    return int(credit > 640)
df['Credit Score'] = df['Credit Score'].apply(good_credit)
df.head()

df['Policy Start Date'] = pd.to_datetime(df['Policy Start Date'] , dayfirst=True)
df.info()

df.head()

df['days_passed'] = (pd.Timestamp.today() - df['Policy Start Date']).dt.days
df.head()

future_loans_index = (df.loc[df['days_passed'] <= 0]).index

#dropping the cols with future references
df.drop(future_loans_index , inplace = True)
df.info()

churn_map = {"No" : 0 , "Yes" : 1}
df['Churn'] = df['Churn'].map(churn_map)
df.head()

int_df = df.drop("Insurance Type" , axis = 1)
str_df = df['Insurance Type']

encoded_str_df = pd.get_dummies(str_df).astype(int)
encoded_str_df

final_df = pd.concat([int_df , encoded_str_df] , axis = 1)

final_df.head()

final_df.drop(['Policy Start Date'] , axis = 1 , inplace = True)
final_df.head()

df.info()

final_df.corr()['Churn']

corr_matrix = final_df.corr()
import seaborn as sns
import matplotlib.pyplot as plt
# Plot the heatmap
plt.figure(figsize=(8, 6))
sns.heatmap(corr_matrix, annot=True, cmap='coolwarm', fmt=".2f", linewidths=0.5)
plt.title('Correlation Matrix')
plt.show()

final_df.head()

sns.boxplot(data = final_df , x = "Claim Amount ($)")

len(final_df)

amount_outliers = final_df.loc[final_df['Claim Amount ($)'] > 1800].index
final_df.drop(amount_outliers , inplace = True)
final_df.info()

sns.boxplot(data = final_df , x = "Earnings ($)")

sns.boxplot(data = final_df , x = "Insurance Plan Amount ($)")

plan_outliers = final_df.loc[final_df['Insurance Plan Amount ($)'] > 12000].index
final_df.drop(plan_outliers , inplace = True)
final_df.info()

sns.boxplot(data = final_df , x = "days_passed")

df = final_df.copy()

df.head()

df.info()

y = df['Churn']
X = df.drop("Churn" , axis = 1)

from sklearn.model_selection import train_test_split
X_train , X_test , y_train , y_test = train_test_split(X , y , test_size = 0.3 , random_state = 101)

scaling_cols = ['Earnings ($)' , 'Claim Amount ($)' , 'Insurance Plan Amount ($)' , 'days_passed']

from sklearn.preprocessing import StandardScaler
scaler = StandardScaler()
X_train[scaling_cols] = scaler.fit_transform(X_train[scaling_cols])
X_test[scaling_cols] = scaler.transform(X_test[scaling_cols])

X_train.head(5)

"""XGBoost gives best results

"""

from  sklearn.metrics import classification_report
from xgboost import XGBClassifier
model = XGBClassifier(n_estimators=1000, learning_rate=0.05, max_depth=3, random_state=42, use_label_encoder=False, eval_metric="logloss")
model.fit(X_train, y_train)

preds = model.predict(X_test)

print("XGBoost Classifier Report:")
print(classification_report(y_test, preds))

import numpy as np
import pandas as pd
from sklearn.metrics.pairwise import cosine_similarity
from datetime import datetime

def preprocess_user_input(user_data):
    processed_data = {}

    # Basic fields
    processed_data['Age'] = user_data['Age']

    # Gender encoding (assuming M=1, F=0 in the preprocessed data)
    processed_data['Gender'] = 1 if user_data['Gender'] == 'M' else 0

    # Earnings
    processed_data['Earnings ($)'] = user_data['Earnings ($)']

    # Claim Amount
    processed_data['Claim Amount ($)'] = user_data['Claim Amount ($)']

    # Insurance Plan Amount
    processed_data['Insurance Plan Amount ($)'] = user_data['Insurance Plan Amount ($)']

    # Plan Type (assuming 1=Basic, 2=Standard, 3=Premium)
    plan_type_map = {'Basic': 1, 'Standard': 2, 'Premium': 3}
    processed_data['Plan Type'] = plan_type_map[user_data['Plan Type']]

    # Credit Score - normalize to 0-1 range
    processed_data['Credit Score'] = user_data['Credit Score'] / 1000  # Assuming max score is around 1000

    # Marital Status (assuming 1=Married, 0=Single)
    processed_data['Marital Status'] = 1 if user_data['Marital Status'] == 'Married' else 0

    # Days passed - calculate days from Policy Start Date to today
    start_date = datetime.strptime(user_data['Policy Start Date'], '%d-%m-%Y')
    days_passed = (datetime.now() - start_date).days / 365  # Normalized by year
    processed_data['days_passed'] = days_passed

    # Insurance types (binary flags)
    insurance_type = user_data['Insurance Type']
    processed_data['Automobile Insurance'] = 1 if 'Automobile' in insurance_type else 0
    processed_data['Health Insurance'] = 1 if 'Health' in insurance_type else 0
    processed_data['Life Insurance'] = 1 if 'Life' in insurance_type else 0

    return pd.Series(processed_data)

def get_similar_customers(customer_profiles, target_customer, n=5):
    combined = pd.concat([pd.DataFrame([target_customer]), customer_profiles])

    similarity_matrix = cosine_similarity(combined)
    similar_indices = similarity_matrix[0, 1:].argsort()[::-1][:n]

    return similar_indices

def generate_recommendations(X, y, target_customer):
    similar_indices = get_similar_customers(X, target_customer)

    # Filter to non-churned similar customers
    non_churned_similar = [idx for idx in similar_indices if y.iloc[idx] == 0]

    if not non_churned_similar:
        return {"General": ["We don't have enough similar customers to provide personalized recommendations."]}

    similar_customers_data = X.iloc[non_churned_similar]
    recommendations = {}

    # 1. Plan Type comparison
    current_plan = target_customer['Plan Type']
    similar_plans = similar_customers_data['Plan Type'].value_counts().idxmax()
    plan_type_map = {1: 'Basic', 2: 'Standard', 3: 'Premium'}

    if current_plan != similar_plans:
        recommendations['Plan_Optimization'] = [
            f"Consider switching to our {plan_type_map[similar_plans]} plan which works well for customers similar to you",
            "Personalized coverage based on your usage patterns"
        ]

    # 2. Check which insurance types are common among similar non-churned customers
    auto_insurance_popular = similar_customers_data['Automobile Insurance'].mean() > 0.5
    health_insurance_popular = similar_customers_data['Health Insurance'].mean() > 0.5
    life_insurance_popular = similar_customers_data['Life Insurance'].mean() > 0.5

    insurance_recs = []
    if auto_insurance_popular and target_customer['Automobile Insurance'] == 0:
        insurance_recs.append("Add automobile insurance - popular among similar customers who stay with us")
    if health_insurance_popular and target_customer['Health Insurance'] == 0:
        insurance_recs.append("Include health insurance coverage - common among customers with your profile")
    if life_insurance_popular and target_customer['Life Insurance'] == 0:
        insurance_recs.append("Consider life insurance protection - beneficial for customers similar to you")

    if insurance_recs:
        recommendations['Insurance_Options'] = insurance_recs

    # 3. Analyze claim behaviors of similar customers
    avg_claim = similar_customers_data['Claim Amount ($)'].mean()
    if target_customer['Claim Amount ($)'] < avg_claim - 0.5:
        recommendations['Claim_Optimization'] = [
            "You may be under-utilizing your benefits compared to similar customers",
            "Schedule a coverage review to ensure you're getting the most from your plan"
        ]
    elif target_customer['Claim Amount ($)'] > avg_claim + 0.5:
        recommendations['Claim_Optimization'] = [
            "Your claim pattern differs from similar satisfied customers",
            "Consider our premium protection plan with higher claim limits"
        ]

    # 4. Credit score-based recommendations
    avg_credit = similar_customers_data['Credit Score'].mean()
    if target_customer['Credit Score'] < avg_credit - 0.1:
        recommendations['Credit_Improvement'] = [
            "Our credit improvement program can help enhance your insurance terms",
            "Customers with improved credit scores often receive better rates"
        ]

    # 5. Demographic insights
    # these are just plain rule based recommendations which is not affected by similar customers
    age = target_customer['Age']
    if age < 30:
        recommendations['Young_Customer'] = [
            "Short-term flexible coverage plans for young professionals",
            "Digital service with mobile app benefits"
        ]
    elif age > 55:
        recommendations['Senior_Customer'] = [
            "Fixed premium rates for long-term loyalty",
            "Priority human customer support"
        ]

    if target_customer['Marital Status'] == 1:
        recommendations['Family_Plans'] = [
            "Family insurance bundle with cost savings",
            "Spouse and children add-on policies"
        ]

    if target_customer['days_passed'] > 1.1 or target_customer['Claim Amount ($)'] < -0.8 or target_customer['Insurance Plan Amount ($)'] > 2.4 :
      recommendations['Good_Customer'] = [
            "3%-5% Discount on insurance plans."
        ]

    # If no specific recommendations were generated, provide a general one
    if not recommendations:
        recommendations['General'] = ["Based on similar customers, your current plan appears optimal."]

    return recommendations

print(X_train['Claim Amount ($)'].min())
print(X_train['Insurance Plan Amount ($)'].min())
print(X_train['days_passed'].min())
print(X_train['Claim Amount ($)'].max())
print(X_train['Insurance Plan Amount ($)'].max())
print(X_train['days_passed'].max())

# parse current services from customer data
def parse_current_services(customer_data):
    services = {}

    if isinstance(customer_data, pd.Series):
        # Insurance Types
        services['Insurance_Types'] = []
        if customer_data.get('Automobile Insurance', 0) == 1:
            services['Insurance_Types'].append('Automobile Insurance')
        if customer_data.get('Health Insurance', 0) == 1:
            services['Insurance_Types'].append('Health Insurance')
        if customer_data.get('Life Insurance', 0) == 1:
            services['Insurance_Types'].append('Life Insurance')

        # Plan Type
        plan_type_map = {1: 'Basic', 2: 'Standard', 3: 'Premium'}
        services['Plan Type'] = plan_type_map[customer_data['Plan Type']]

        # Credit Score
        services['Credit Score'] = 'Good' if customer_data['Credit Score'] > 0.65 else 'Poor'

        # Marital Status
        services['Marital Status'] = 'Married' if customer_data['Marital Status'] == 1 else 'Single'
    else:
        # For original format input
        services['Insurance_Types'] = [customer_data['Insurance Type']]
        services['Plan Type'] = customer_data['Plan Type']
        services['Credit Score'] = 'Good' if customer_data['Credit Score'] > 650 else 'Poor'
        services['Marital Status'] = customer_data['Marital Status']

    return services

def interactive_customer_recommendations(X, y, model):
    print("Welcome to the Insurance Customer Churn Prevention System")
    print("Please enter customer information to receive personalized recommendations")

    while True:
        try:
            print("\n" + "="*50)
            print("Enter customer details (or type 'exit' to quit)")

            name_input = input("Name: ")
            if name_input.lower() == 'exit':
                print("Thank you for using our services")
                break

            # Collect user input based on the original format
            user_data = {
                'Name': name_input,
                'Age': int(input("Age: ")),
                'Gender': input("Gender (M/F): ").upper(),
                'Insurance Type': input("Insurance Type (Automobile/Health/Life): "),
                'Earnings ($)': float(input("Earnings ($): ")),
                'Claim Amount ($)': float(input("Claim Amount ($): ")),
                'Insurance Plan Amount ($)': float(input("Insurance Plan Amount ($): ")),
                'Plan Type': input("Plan Type (Basic/Standard/Premium): "),
                'Credit Score': int(input("Credit Score: ")),
                'Marital Status': input("Marital Status (Single/Married): "),
                'Policy Start Date': input("Policy Start Date (DD-MM-YYYY): ")
            }

            processed_user_data = preprocess_user_input(user_data)

            # Print customer analysis header
            print("\nCustomer Analysis for", user_data['Name'])
            print("-" * 50)

            # Ensure the processed data has the same columns as the training data
            missing_cols = set(X.columns) - set(processed_user_data.index)
            for col in missing_cols:
                processed_user_data[col] = 0

            # Make sure columns are in the same order
            processed_user_data = processed_user_data[X.columns]

            # Create input DataFrame for model prediction (XGBoost expects DataFrame)
            input_df = pd.DataFrame([processed_user_data])

            # Use the XGBoost model to predict churn probability
            churn_prob = model.predict_proba(input_df)[0][1]  # Get probability of positive class (churn)

            # Determine risk category
            if churn_prob < 0.3:
                risk_category = "Low Risk"
            elif churn_prob < 0.6:
                risk_category = "Medium Risk"
            else:
                risk_category = "High Risk"

            print(f"Customer Churn Risk: {risk_category} ({churn_prob:.1%} probability)")

            # Current services
            print("\nCurrent Services:")
            current = parse_current_services(user_data)
            print(f"Plan Type: {current['Plan Type']}")
            print(f"Insurance Types: {', '.join(current['Insurance_Types']) if current['Insurance_Types'] else 'None'}")
            print(f"Credit Score Status: {current['Credit Score']}")
            print(f"Marital Status: {current['Marital Status']}")

            # Generate recommendations based on similarity
            recommendations = generate_recommendations(X, y, processed_user_data)

            # Display recommendations
            print("\nPersonalized Recommendations (Based on Similar Customers):")
            if recommendations:
                for category, recs in recommendations.items():
                    if isinstance(recs, list):
                        for rec in recs:
                            print(f"- {rec}")
                    else:
                        print(f"- {recs}")
            else:
                print("No specific recommendations at this time.")

        except ValueError as e:
            print(f"Error: {e}")
            print("Please enter valid data in the correct format")
        except Exception as e:
            print(f"An unexpected error occurred: {e}")
            print("Please try again")


if __name__ == "__main__":
    from xgboost import XGBClassifier
    model = XGBClassifier(n_estimators=1000, learning_rate=0.05, max_depth=3, random_state=42, use_label_encoder=False, eval_metric="logloss")
    model.fit(X_train, y_train)


    # Interactive recommender
    interactive_customer_recommendations(X_train, y_train, model)

# example values to enter

# 'ID': 'AB0005', 'Name': 'Pooja Agarwal', 'Age': 35, 'Gender': 'M',
#             'Insurance Type': 'Health Insurance', 'Earnings ($)': 60871.42,
#             'Claim Amount ($)': 723.11, 'Insurance Plan Amount ($)': 9007.93,
#             'Plan Type': 'Standard', 'Credit Score': 598, 'Marital Status': 'Married',
#             'Policy Start Date': '22-09-2020', 'Churn': 'No'

# 'ID': 'AB0001', 'Name': 'Shreya Patel', 'Age': 58, 'Gender': 'M',
#             'Insurance Type': 'Health Insurance', 'Earnings ($)': 68668.48,
#             'Claim Amount ($)': 429.30, 'Insurance Plan Amount ($)': 7412.89,
#             'Plan Type': 'Basic', 'Credit Score': 648, 'Marital Status': 'Single',
#             'Policy Start Date': '27-04-2014', 'Churn': 'No'

import pickle
with open("ml_model.pkl", "wb") as file:
    pickle.dump(model, file)

print("Model saved successfully!")